# $Id$

package XML::Atom::Client;
use strict;

use XML::Atom;
use base qw( XML::Atom::ErrorHandler );
use LWP::UserAgent;
use XML::Atom::Entry;
use XML::Atom::Feed;
use XML::Atom::Util qw( first textValue );
use Digest::SHA1 qw( sha1 );
use MIME::Base64 qw( encode_base64 );
use DateTime;

use constant NS_SOAP => 'http://schemas.xmlsoap.org/soap/envelope/';

sub new {
    my $class = shift;
    my $client = bless { }, $class;
    $client->init(@_) or return $class->error($client->errstr);
    $client;
}

sub init {
    my $client = shift;
    my %param = @_;
    $client->{ua} = LWP::UserAgent::AtomClient->new($client);
    $client->{ua}->agent('XML::Atom/' . XML::Atom->VERSION);
    $client->{ua}->parse_head(0);
    $client;
}

sub username {
    my $client = shift;
    $client->{username} = shift if @_;
    $client->{username};
}

sub password {
    my $client = shift;
    $client->{password} = shift if @_;
    $client->{password};
}

sub use_soap {
    my $client = shift;
    $client->{use_soap} = shift if @_;
    $client->{use_soap};
}

sub auth_digest {
    my $client = shift;
    $client->{auth_digest} = shift if @_;
    $client->{auth_digest};
}

sub getEntry {
    my $client = shift;
    my($url) = @_;
    my $req = HTTP::Request->new(GET => $url);
    my $res = $client->make_request($req);
    return $client->error("Error on GET $url: " . $res->status_line)
        unless $res->code == 200;
    XML::Atom::Entry->new(Stream => \$res->content);
}

sub createEntry {
    my $client = shift;
    my($uri, $entry) = @_;
    return $client->error("Must pass a PostURI before posting")
        unless $uri;
    my $req = HTTP::Request->new(POST => $uri);
    $req->content_type($entry->content_type);
    my $xml = $entry->as_xml;
    _utf8_off($xml);
    $req->content_length(length $xml);
    $req->content($xml);
    my $res = $client->make_request($req);
    return $client->error("Error on POST $uri: " . $res->status_line)
        unless $res->code == 201;
    $res->header('Location') || 1;
}

sub updateEntry {
    my $client = shift;
    my($url, $entry) = @_;
    my $req = HTTP::Request->new(PUT => $url);
    $req->content_type($entry->content_type);
    my $xml = $entry->as_xml;
    _utf8_off($xml);
    $req->content_length(length $xml);
    $req->content($xml);
    my $res = $client->make_request($req);
    return $client->error("Error on PUT $url: " . $res->status_line)
        unless $res->code == 200;
    1;
}

sub deleteEntry {
    my $client = shift;
    my($url) = @_;
    my $req = HTTP::Request->new(DELETE => $url);
    my $res = $client->make_request($req);
    return $client->error("Error on DELETE $url: " . $res->status_line)
        unless $res->code == 200;
    1;
}

sub getFeed {
    my $client = shift;
    my($uri) = @_;
    return $client->error("Must pass a FeedURI before retrieving feed")
        unless $uri;
    my $req = HTTP::Request->new(GET => $uri);
    my $res = $client->make_request($req);
    return $client->error("Error on GET $uri: " . $res->status_line)
        unless $res->code == 200;
    my $feed = XML::Atom::Feed->new(Stream => \$res->content)
        or return $client->error(XML::Atom::Feed->errstr);
    $feed;
}

sub make_request {
    my $client = shift;
    my($req) = @_;
    $client->munge_request($req);
    my $res = $client->{ua}->request($req);
    $client->munge_response($res);
    $client->{response} = $res;
    $res;
}

sub munge_request {
    my $client = shift;
    my($req) = @_;
    $req->header(
        Accept => 'application/atom+xml, application/x.atom+xml, application/xml, text/xml, */*',
    );
    my $nonce = $client->make_nonce;
    my $nonce_enc = encode_base64($nonce, '');
    my $now = DateTime->now->iso8601 . 'Z';
    my $digest = encode_base64(sha1($nonce . $now . ($client->password || '')), '');
    if ($client->use_soap) {
        my $xml = $req->content || '';
        $xml =~ s!^(<\?xml.*?\?>)!!;
        my $method = $req->method;
        $xml = ($1 || '') . <<SOAP;
<soap:Envelope
  xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
  xmlns:wsu="http://schemas.xmlsoap.org/ws/2002/07/utility"
  xmlns:wsse="http://schemas.xmlsoap.org/ws/2002/07/secext">
  <soap:Header>
    <wsse:Security>
      <wsse:UsernameToken>
        <wsse:Username>@{[ $client->username || '' ]}</wsse:Username>
        <wsse:Password Type="wsse:PasswordDigest">$digest</wsse:Password>
        <wsse:Nonce>$nonce_enc</wsse:Nonce>
        <wsu:Created>$now</wsu:Created>
      </wsse:UsernameToken>
    </wsse:Security>
  </soap:Header>
  <soap:Body>
    <$method xmlns="http://schemas.xmlsoap.org/wsdl/http/">
$xml
    </$method>
  </soap:Body>
</soap:Envelope>
SOAP
        $req->content($xml);
        $req->content_length(length $xml);
        $req->header('SOAPAction', 'http://schemas.xmlsoap.org/wsdl/http/' . $method);
        $req->method('POST');
        $req->content_type('text/xml');
    } else {
        if ($client->username) {
            $req->header('X-WSSE', sprintf
              qq(UsernameToken Username="%s", PasswordDigest="%s", Nonce="%s", Created="%s"),
              $client->username || '', $digest, $nonce_enc, $now);
            $req->header('Authorization', 'WSSE profile="UsernameToken"');
        }
    }
}

sub munge_response {
    my $client = shift;
    my($res) = @_;
    if ($client->use_soap && (my $xml = $res->content)) {
        my $doc;
        if (LIBXML) {
            my $parser = XML::LibXML->new;
            $doc = $parser->parse_string($xml);
        } else {
            my $xp = XML::XPath->new(xml => $xml);
            $doc = ($xp->find('/')->get_nodelist)[0];
        }
        my $body = first($doc, NS_SOAP, 'Body');
        if (my $fault = first($body, NS_SOAP, 'Fault')) {
            $res->code(textValue($fault, undef, 'faultcode'));
            $res->message(textValue($fault, undef, 'faultstring'));
            $res->content('');
            $res->content_length(0);
        } else {
            $xml = join '', map $_->toString(LIBXML ? 1 : 0),
                LIBXML ? $body->childNodes : $body->getChildNodes;
            $res->content($xml);
            $res->content_length(1);
        }
    }
}

sub make_nonce { sha1(sha1(time() . {} . rand() . $$)) }

sub _utf8_off {
    if ($] >= 5.008) {
        require Encode;
        Encode::_utf8_off($_[0]);
    }
}

package LWP::UserAgent::AtomClient;
use strict;
use Scalar::Util;

use base qw( LWP::UserAgent );

my %ClientOf;
sub new {
    my($class, $client) = @_;
    my $ua = $class->SUPER::new;
    $ClientOf{$ua} = $client;
    Scalar::Util::weaken($ClientOf{$ua});
    $ua;
}

sub get_basic_credentials {
    my($ua, $realm, $url, $proxy) = @_;
    my $client = $ClientOf{$ua} or die "Cannot find $ua";
    return $client->username, $client->password;
}

sub DESTROY {
    my $self = shift;
    delete $ClientOf{$self};
}

1;
__END__

=head1 NAME

XML::Atom::Client - A client for the Atom API

=head1 SYNOPSIS

    use XML::Atom::Client;
    use XML::Atom::Entry;
    my $api = XML::Atom::Client->new;
    $api->username('Melody');
    $api->password('Nelson');

    my $entry = XML::Atom::Entry->new;
    $entry->title('New Post');
    $entry->content('Content of my post.');
    my $EditURI = $api->createEntry($PostURI, $entry);

    my $feed = $api->getFeed($FeedURI);
    my @entries = $feed->entries;

    my $entry = $api->getEntry($EditURI);

=head1 DESCRIPTION

I<XML::Atom::Client> implements a client for the Atom API described at
I<http://bitworking.org/projects/atom/draft-gregorio-09.html>, with the
authentication scheme described at
I<http://www.intertwingly.net/wiki/pie/DifferentlyAbledClients>.

B<NOTE:> the API, and particularly the authentication scheme, are still
in flux.

=head1 USAGE

=head2 XML::Atom::Client->new(%param)

=head2 $api->use_soap([ 0 | 1 ])

I<XML::Atom::Client> supports both the REST and SOAP-wrapper versions of the
Atom API. By default, the REST version of the API will be used, but you can
turn on the SOAP wrapper--for example, if you need to connect to a server
that supports only the SOAP wrapper--by calling I<use_soap> with a value of
C<1>:

    $api->use_soap(1);

If called without arguments, returns the current value of the flag.

=head2 $api->username([ $username ])

If called with an argument, sets the username for login to I<$username>.

Returns the current username that will be used when logging in to the
Atom server.

=head2 $api->password([ $password ])

If called with an argument, sets the password for login to I<$password>.

Returns the current password that will be used when logging in to the
Atom server.

=head2 $api->createEntry($PostURI, $entry)

Creates a new entry.

I<$entry> must be an I<XML::Atom::Entry> object.

=head2 $api->getEntry($EditURI)

Retrieves the entry with the given URL I<$EditURI>.

Returns an I<XML::Atom::Entry> object.

=head2 $api->updateEntry($EditURI, $entry)

Updates the entry at URL I<$EditURI> with the entry I<$entry>, which must be
an I<XML::Atom::Entry> object.

Returns true on success, false otherwise.

=head2 $api->deleteEntry($EditURI)

Deletes the entry at URL I<$EditURI>.

=head2 $api->getFeed($FeedURI)

Retrieves the feed at I<$FeedURI>.

Returns an I<XML::Atom::Feed> object representing the feed returned
from the server.

=head2 ERROR HANDLING

Methods return C<undef> on error, and the error message can be retrieved
using the I<errstr> method.

=head1 AUTHOR & COPYRIGHT

Please see the I<XML::Atom> manpage for author, copyright, and license
information.

=cut
for the requested line, so you would see an
error like:

  Example version 1.002003 (v1.2.3) required--this is only version 1.002002 (v1.2.2)...

=item Dotted-Decimal version work sometimes

With Perl >= 5.6.2, you can also use a line like this:

  use Example 1.2.3;

and it will again work (i.e. give the error message as above), even with
releases of Perl which do not normally support v-strings (see L<What about
v-strings> below).  This has to do with that fact that C<use> only checks
to see if the second term I<looks like a number> and passes that to the
replacement L<UNIVERSAL::VERSION>.  This is not true in Perl 5.005_04,
however, so you are B<strongly encouraged> to always use a Decimal version
in your code, even for those versions of Perl which support the Dotted-Decimal
version.

=back

=head2 Object Methods

Overloading has been used with version objects to provide a natural
interface for their use.  All mathematical operations are forbidden,
since they don't make any sense for base version objects.  Consequently,
there is no overloaded numification available.  If you want to use a
version object in a Decimal context for some reason, see the L<numify>
object method.

=over 4

=item * New Operator

Like all OO interfaces, the new() operator is used to initialize
version objects.  One way to increment versions when programming is to
use the CVS variable $Revision, which is automatically incremented by
CVS every time the file is committed to the repository.

In order to facilitate this feature, the following
code can be employed:

  $VERSION = version->new(qw$Revision: 2.7 $);

and the version object will be created as if the following code
were used:

  $VERSION = version->new("v2.7");

In other words, the version will be automatically parsed out of the
string, and it will be quoted to preserve the meaning CVS normally
carries for versions.  The CVS $Revision$ increments differently from
Decimal versions (i.e. 1.10 follows 1.9), so it must be handled as if
it were a L<Dotted-Decimal Version>.

A new version object can be created as a copy of an existing version
object, either as a class method:

  $v1 = version->new(12.3);
  $v2 = version->new($v1);

or as an object method:

  $v1 = version->new(12.3);
  $v2 = $v1->new(12.3);

and in each case, $v1 and $v2 will be identical.  NOTE: if you create
a new object using an existing object like this:

  $v2 = $v1->new();

the new object B<will not> be a clone of the existing object.  In the
example case, $v2 will be an empty object of the same type as $v1.

=back

=over 4

=item * qv()

An alternate way to create a new version object is through the exported
qv() sub.  This is not strictly like other q? operators (like qq, qw),
in that the only delimiters supported are parentheses (or spaces).  It is
the best way to initialize a short version without triggering the floating
point interpretation.  For example:

  $v1 = qv(1.2);         # v1.2.0
  $v2 = qv("1.2");       # also v1.2.0

As you can see, either a bare number or a quoted string can usually 
be used interchangably, except in the case of a trailing zero, which
must be quoted to be converted properly.  For this reason, it is strongly
recommended that all initializers to qv() be quoted strings instead of
bare numbers.

To prevent the C<qv()> function from being exported to the caller's namespace,
either use version with a null parameter:

  use version ();

or just require version, like this:

  require version;

Both methods will prevent the import() method from firing and exporting the
C<qv()> sub.  This is true of subclasses of version as well, see
L<SUBCLASSING> for details.

=back

For the subsequent examples, the following three objects will be used:

  $ver   = version->new("1.2.3.4"); # see "Quoting" below
  $alpha = version->new("1.2.3_4"); # see "Alpha versions" below
  $nver  = version->new(1.002);     # see "Decimal Versions" above

=over 4

=item * Normal Form

For any version object which is initialized with multiple decimal
places (either quoted or if possible v-string), or initialized using
the L<qv()> operator, the stringified representation is returned in
a normalized or reduced form (no extraneous zeros), and with a leading 'v':

  print $ver->normal;         # prints as v1.2.3.4
  print $ver->stringify;      # ditto
  print $ver;                 # ditto
  print $nver->normal;        # prints as v1.2.0
  print $nver->stringify;     # prints as 1.002, see "Stringification" 

In order to preserve the meaning of the processed version, the 
normalized representation will always contain at least three sub terms.
In other words, the following is guaranteed to always be true:

  my $newver = version->new($ver->stringify);
  if ($newver eq $ver ) # always true
    {...}

=back

=over 4

=item * Numification

Although all mathematical operations on version objects are forbidden
by default, it is possible to retrieve a number which corresponds 
to the version object through the use of the $obj->numify
method.  For formatting purposes, when displaying a number which
corresponds a version object, all sub versions are assumed to have
three decimal places.  So for example:

  print $ver->numify;         # prints 1.002003004
  print $nver->numify;        # prints 1.002

Unlike the stringification operator, there is never any need to append
trailing zeros to preserve the correct version value.

=back

=over 4

=item * Stringification

The default stringification for version objects returns exactly the same
string as was used to create it, whether you used C<new()> or C<qv()>,
with one exception.  The sole exception is if the object was created using
C<qv()> and the initializer did not have two decimal places or a leading
'v' (both optional), then the stringified form will have a leading 'v'
prepended, in order to support round-trip processing.

For example:

  Initialized as          Stringifies to
  ==============          ==============
  version->new("1.2")       1.2
  version->new("v1.2")     v1.2
  qv("1.2.3")               1.2.3
  qv("v1.3.5")             v1.3.5
  qv("1.2")                v1.2   ### exceptional case 

See also L<UNIVERSAL::VERSION>, as this also returns the stringified form
when used as a class method.

IMPORTANT NOTE: There is one exceptional cases shown in the above table
where the "initializer" is not stringwise equivalent to the stringified
representation.  If you use the C<qv()> operator on a version without a
leading 'v' B<and> with only a single decimal place, the stringified output
will have a leading 'v', to preserve the sense.  See the L<qv()> operator
for more details.

IMPORTANT NOTE 2: Attempting to bypass the normal stringification rules by
manually applying L<numify()> and L<normal()> will sometimes yield
surprising results:

  print version->new(version->new("v1.0")->numify)->normal; # v1.0.0

The reason for this is that the L<numify()> operator will turn "v1.0"
into the equivalent string "1.000000".  Forcing the outer version object
to L<normal()> form will display the mathematically equivalent "v1.0.0".

As the example in L<new()> shows, you can always create a copy of an
existing version object with the same value by the very compact:

  $v2 = $v1->new($v1);

and be assured that both C<$v1> and C<$v2> will be completely equivalent,
down to the same internal representation as well as stringification.

=back

=over 4

=item * Comparison operators

Both C<cmp> and C<E<lt>=E<gt>> operators perform the same comparison between
terms (upgrading to a version object automatically).  Perl automatically
generates all of the other comparison operators based on those two.
In addition to the obvious equalities listed below, appending a single
trailing 0 term does not change the value of a version for comparison
purposes.  In other words "v1.2" and "1.2.0" will compare as identical.

For example, the following relations hold:

  As Number        As String           Truth Value
  -------------    ----------------    -----------
  $ver >  1.0      $ver gt "1.0"       true
  $ver <  2.5      $ver lt             true
  $ver != 1.3      $ver ne "1.3"       true
  $ver == 1.2      $ver eq "1.2"       false
  $ver == 1.2.3.4  $ver eq "1.2.3.4"   see discussion below

It is probably best to chose either the Decimal notation or the string
notation and stick with it, to reduce confusion.  Perl6 version objects
B<may> only support Decimal comparisons.  See also L<Quoting>.

WARNING: Comparing version with unequal numbers of decimal points (whether
explicitly or implicitly initialized), may yield unexpected results at
first glance.  For example, the following inequalities hold:

  version->new(0.96)     > version->new(0.95); # 0.960.0 > 0.950.0
  version->new("0.96.1") < version->new(0.95); # 0.096.1 < 0.950.0

For this reason, it is best to use either exclusively L<Decimal Versions> or
L<Dotted-Decimal Versions> with multiple decimal points.

=back

=over 4

=item * Logical Operators 

If you need to test whether a version object
has been initialized, you can simply test it directly:

  $vobj = version->new($something);
  if ( $vobj )   # true only if $something was non-blank

You can also test whether a version object is an L<Alpha version>, for
example to prevent the use of some feature not present in the main
release:

  $vobj = version->new("1.2_3"); # MUST QUOTE
  ...later...
  if ( $vobj->is_alpha )       # True

=back

=head2 Quoting

Because of the nature of the Perl parsing and tokenizing routines,
certain initialization values B<must> be quoted in order to correctly
parse as the intended version, especially when using the L<qv()> operator.
In all cases, a floating point number passed to version->new() will be
identically converted whether or not the value itself is quoted.  This is
not true for L<qv()>, however, when trailing zeros would be stripped on
an unquoted input, which would result in a very different version object.

In addition, in order to be compatible with earlier Perl version styles,
any use of versions of the form 5.006001 will be translated as v5.6.1.  
In other words, a version with a single decimal point will be parsed as
implicitly having three digits between subversions, but only for internal
comparison purposes.

The complicating factor is that in bare numbers (i.e. unquoted), the
underscore is a legal Decimal character and is automatically stripped
by the Perl tokenizer before the version code is called.  However, if
a number containing one or more decimals and an underscore is quoted, i.e.
not bare, that is considered a L<Alpha Version> and the underscore is
significant.

If you use a mathematic formula that resolves to a floating point number,
you are dependent on Perl's conversion routines to yield the version you
expect.  You are pretty safe by dividing by a power of 10, for example,
but other operations are not likely to be what you intend.  For example:

  $VERSION = version->new((qw$Revision: 1.4)[1]/10);
  print $VERSION;          # yields 0.14
  $V2 = version->new(100/9); # Integer overflow in decimal number
  print $V2;               # yields something like 11.111.111.100

Perl 5.8.1 and beyond will be able to automatically quote v-strings but
that is not possible in earlier versions of Perl.  In other words:

  $version = version->new("v2.5.4");  # legal in all versions of Perl
  $newvers = version->new(v2.5.4);    # legal only in Perl >= 5.8.1

=head1 SUBCLASSING

This module is specifically designed and tested to be easily subclassed.
In practice, you only need to override the methods you want to change, but
you have to take some care when overriding new() (since that is where all
of the parsing takes place).  For example, this is a perfect acceptable
derived class:

  package myversion;
  use base version;
  sub new { 
      my($self,$n)=@_;
      my $obj;
      # perform any special input handling here
      $obj = $self->SUPER::new($n);
      # and/or add additional hash elements here
      return $obj;
  }

See also L<version::AlphaBeta> on CPAN for an alternate representation of
version strings.

B<NOTE:> Although the L<qv> operator is not a true class method, but rather a
function exported into the caller's namespace, a subclass of version will 
inherit an import() function which will perform the correct magic on behalf
of the subclass.

=head1 EXPORT

qv - Dotted-Decimal Version initialization operator

=head1 AUTHOR

John Peacock E<lt>jpeacock@cpan.orgE<gt>

=head1 SEE ALSO

L<perl>.

=cut
